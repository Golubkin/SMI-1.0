<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMI (Super-Mega-Interpreter): Файл D:/Road to the Dream/SMI/SMI-1.0/MathFunctions/MathFunctions.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SMI (Super-Mega-Interpreter)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_math_functions_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Функции</a>  </div>
  <div class="headertitle">
<div class="title">Файл MathFunctions.h</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="_math_functions_8h_source.html">См. исходные тексты.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Функции</h2></td></tr>
<tr class="memitem:a8ddbdb34f3fe68739bfdd99b01701de7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a8ddbdb34f3fe68739bfdd99b01701de7">SMIfloor</a> (double)</td></tr>
<tr class="memdesc:a8ddbdb34f3fe68739bfdd99b01701de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Функция округления вниз.  <a href="_math_functions_8h.html#a8ddbdb34f3fe68739bfdd99b01701de7">Подробнее...</a><br /></td></tr>
<tr class="separator:a8ddbdb34f3fe68739bfdd99b01701de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7586ab4c83cc8dd089233279c183155"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#aa7586ab4c83cc8dd089233279c183155">SMIceil</a> (double)</td></tr>
<tr class="memdesc:aa7586ab4c83cc8dd089233279c183155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Функция округления вверх.  <a href="_math_functions_8h.html#aa7586ab4c83cc8dd089233279c183155">Подробнее...</a><br /></td></tr>
<tr class="separator:aa7586ab4c83cc8dd089233279c183155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2bf3695b1d2bc09487066ea01ccd01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a4d2bf3695b1d2bc09487066ea01ccd01">SMIround</a> (double)</td></tr>
<tr class="memdesc:a4d2bf3695b1d2bc09487066ea01ccd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Стандартное округление.  <a href="_math_functions_8h.html#a4d2bf3695b1d2bc09487066ea01ccd01">Подробнее...</a><br /></td></tr>
<tr class="separator:a4d2bf3695b1d2bc09487066ea01ccd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e2243a88ab548435113ee795b65f4c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a02e2243a88ab548435113ee795b65f4c">SMIabs</a> (double)</td></tr>
<tr class="memdesc:a02e2243a88ab548435113ee795b65f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Модуль числа.  <a href="_math_functions_8h.html#a02e2243a88ab548435113ee795b65f4c">Подробнее...</a><br /></td></tr>
<tr class="separator:a02e2243a88ab548435113ee795b65f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb423fbff3619ef43012282a2988dbc"><td class="memItemLeft" align="right" valign="top">unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a0fb423fbff3619ef43012282a2988dbc">SMIfact</a> (unsigned int)</td></tr>
<tr class="memdesc:a0fb423fbff3619ef43012282a2988dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Факториал числа.  <a href="_math_functions_8h.html#a0fb423fbff3619ef43012282a2988dbc">Подробнее...</a><br /></td></tr>
<tr class="separator:a0fb423fbff3619ef43012282a2988dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf7a4b034c50a026040e1ab2f579105"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#adaf7a4b034c50a026040e1ab2f579105">SMIln</a> (double)</td></tr>
<tr class="memdesc:adaf7a4b034c50a026040e1ab2f579105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Натуральный логарифм числа.  <a href="_math_functions_8h.html#adaf7a4b034c50a026040e1ab2f579105">Подробнее...</a><br /></td></tr>
<tr class="separator:adaf7a4b034c50a026040e1ab2f579105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434939ee9df839189e2ff5173543e34e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a434939ee9df839189e2ff5173543e34e">SMIexp</a> (double)</td></tr>
<tr class="memdesc:a434939ee9df839189e2ff5173543e34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Число е в степени x.  <a href="_math_functions_8h.html#a434939ee9df839189e2ff5173543e34e">Подробнее...</a><br /></td></tr>
<tr class="separator:a434939ee9df839189e2ff5173543e34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f36797cbf72fdcd89feecb450fcd32a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a6f36797cbf72fdcd89feecb450fcd32a">SMIpow</a> (double, double)</td></tr>
<tr class="memdesc:a6f36797cbf72fdcd89feecb450fcd32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Функция \(\ x^n \).  <a href="_math_functions_8h.html#a6f36797cbf72fdcd89feecb450fcd32a">Подробнее...</a><br /></td></tr>
<tr class="separator:a6f36797cbf72fdcd89feecb450fcd32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c258aa57a2b36e8c08dbd110e8d24c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#ad6c258aa57a2b36e8c08dbd110e8d24c">SMIsqrt</a> (double)</td></tr>
<tr class="memdesc:ad6c258aa57a2b36e8c08dbd110e8d24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Квадратный корень.  <a href="_math_functions_8h.html#ad6c258aa57a2b36e8c08dbd110e8d24c">Подробнее...</a><br /></td></tr>
<tr class="separator:ad6c258aa57a2b36e8c08dbd110e8d24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17592d9867c7b061aee2b98cdf1be20f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a17592d9867c7b061aee2b98cdf1be20f">SMIsin</a> (double)</td></tr>
<tr class="memdesc:a17592d9867c7b061aee2b98cdf1be20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Синус.  <a href="_math_functions_8h.html#a17592d9867c7b061aee2b98cdf1be20f">Подробнее...</a><br /></td></tr>
<tr class="separator:a17592d9867c7b061aee2b98cdf1be20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ce4880b9de89153cfa528e4269b956"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a51ce4880b9de89153cfa528e4269b956">SMIcos</a> (double)</td></tr>
<tr class="memdesc:a51ce4880b9de89153cfa528e4269b956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Косинус.  <a href="_math_functions_8h.html#a51ce4880b9de89153cfa528e4269b956">Подробнее...</a><br /></td></tr>
<tr class="separator:a51ce4880b9de89153cfa528e4269b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296bd063698115c559b4acc0b0d55458"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a296bd063698115c559b4acc0b0d55458">SMItg</a> (double)</td></tr>
<tr class="memdesc:a296bd063698115c559b4acc0b0d55458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Тангенс.  <a href="_math_functions_8h.html#a296bd063698115c559b4acc0b0d55458">Подробнее...</a><br /></td></tr>
<tr class="separator:a296bd063698115c559b4acc0b0d55458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ec07fbaff5076760f64c4bcfe4eadd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#a97ec07fbaff5076760f64c4bcfe4eadd">SMIctg</a> (double)</td></tr>
<tr class="memdesc:a97ec07fbaff5076760f64c4bcfe4eadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Котангенс.  <a href="_math_functions_8h.html#a97ec07fbaff5076760f64c4bcfe4eadd">Подробнее...</a><br /></td></tr>
<tr class="separator:a97ec07fbaff5076760f64c4bcfe4eadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d8d5cd2b5e9edf4d08f34e03ac181e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_math_functions_8h.html#ad2d8d5cd2b5e9edf4d08f34e03ac181e">SMIlog</a> (double, double)</td></tr>
<tr class="memdesc:ad2d8d5cd2b5e9edf4d08f34e03ac181e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Логарифм числа.  <a href="_math_functions_8h.html#ad2d8d5cd2b5e9edf4d08f34e03ac181e">Подробнее...</a><br /></td></tr>
<tr class="separator:ad2d8d5cd2b5e9edf4d08f34e03ac181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Функции</h2>
<a id="a02e2243a88ab548435113ee795b65f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e2243a88ab548435113ee795b65f4c">&#9670;&nbsp;</a></span>SMIabs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIabs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Модуль числа. </p>
<p>Функция возвращает модуль числа x.</p>
<p>1.Если число типа double больше либо равно нулю, то функция возвращает это число.</p>
<p>2.Если число типа double меньше нуля, то функция возвращает противоположное число.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7586ab4c83cc8dd089233279c183155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7586ab4c83cc8dd089233279c183155">&#9670;&nbsp;</a></span>SMIceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SMIceil </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Функция округления вверх. </p>
<p>Функция возвращает минимальное целое, которое не меньше x.</p>
<p>1.Если число типа double положительное и без остатка, то функция возвращает это число, округленное в тип int. В случае если число с остатком, то возвращается число преобразованное в тип int и увеличенное на единицу.</p>
<p>2.Если число типа double меньше либо равно нулю, то функция возвращает число преобразованное в тип int.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51ce4880b9de89153cfa528e4269b956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ce4880b9de89153cfa528e4269b956">&#9670;&nbsp;</a></span>SMIcos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIcos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Косинус. </p>
<p>Функция возвращает косинус угла х (радианы).</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double</td></tr>
  </table>
  </dd>
</dl>
<p>Функция работает с использование функции SMIsin на основе формулы приведения \(\ sin((pi/2) - x) = cos(x) \) </p>

</div>
</div>
<a id="a97ec07fbaff5076760f64c4bcfe4eadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ec07fbaff5076760f64c4bcfe4eadd">&#9670;&nbsp;</a></span>SMIctg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIctg </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Котангенс. </p>
<p>Функция возвращает котангенс угла х (радианы).</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double</td></tr>
  </table>
  </dd>
</dl>
<p>Реализуется по определению котангенса. Путем деления SMIcos(x) на SMIsin(x). </p>

</div>
</div>
<a id="a434939ee9df839189e2ff5173543e34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434939ee9df839189e2ff5173543e34e">&#9670;&nbsp;</a></span>SMIexp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIexp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Число е в степени x. </p>
<p>Функция возвращает \(\ e^x \). Онована на ряде Маклорена \(\ e^x = 1 + x / 1! + x^2 / 2! + x^3 / 3! + ...\)(ограничились десятью слагаемыми)</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double</td></tr>
  </table>
  </dd>
</dl>
<p>Принцип работы:</p>
<p>1.Если |x| &lt;= 1.</p>
<p>Заводим цикл while пока не пройдем все слагаемые(n = 10) ряда Маклорена. Внутри заводим цикл for и возводим x в степень. Затем реализуем формулу ряда Маклорена с помощью факториала SMIfact(n). И так пока не закончит работать цикл while.</p>
<p>2.Если x \(\ &gt; \) 1.</p>
<p>Здесь реализуется свойство степеней с одинаковыми основаниями \(\ a^b * a^c = a^{b+c} \).</p>
<p>Для этого заводим две новые переменные, которые разделяют дробное число на целую часть и дробную.</p>
<p>Переменная x округляется вниз с помощью SMIfloor(x), получая на выходе int_x, а fract_x находит дробную часть. Далее с помощью цикла for возводим e в целую степень, а в результате получаем произведение этой экспаненты на SMIexp(fract_x) (то есть e в оставшейся дробной степени).</p>
<p>3.Если x &lt; -1.0</p>
<p>Реализуется наподобие как и в пункте 2. Только округление отрицательных чисел производится с помощью SMIceil(x). Далее представляем число в отрицательной степени как один делить на то же число только в положительной степени. И используем готовую функцию SMIexp(fract_x). </p>

</div>
</div>
<a id="a0fb423fbff3619ef43012282a2988dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb423fbff3619ef43012282a2988dbc">&#9670;&nbsp;</a></span>SMIfact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int SMIfact </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Факториал числа. </p>
<p>Функция возвращает факториал числа x.</p>
<dl class="section warning"><dt>Предупреждения</dt><dd>Функция не работает для x &gt; 20. Так как факториал очень быстро растет.</dd></dl>
<p>1.Функция работает по принципу рекурсии. Если число x типа unsigned int больше единицы, то значение x умножаем на вызов функции. И так до тех пор, пока x не станет равным единице или нулю.</p>
<p>2.Если число x типа unsigned int равняется единице или нулю, то функция возвращает единицу.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа unsigned int . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ddbdb34f3fe68739bfdd99b01701de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddbdb34f3fe68739bfdd99b01701de7">&#9670;&nbsp;</a></span>SMIfloor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SMIfloor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Функция округления вниз. </p>
<p>Функция возвращает максимальное целое, не превышающее x.</p>
<p>1.Если число типа double больше или равно нуля, то функция возвращает это число преобразованное в тип int.</p>
<p>2.Если число типа double меньше нуля и без остатка, то функция возвращает это число преобразованное в тип int. В случае, если число отрицательное и дробое, то функция возвращает число преобразованное в int, уменьшенное на единицу.(Например, число -3,5 округлится до -4)</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf7a4b034c50a026040e1ab2f579105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf7a4b034c50a026040e1ab2f579105">&#9670;&nbsp;</a></span>SMIln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIln </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Натуральный логарифм числа. </p>
<p>Функция ln(x). \(\ ln(1+x) = x - x^2 / 2 + x^3 / 3 - x^4 / 4 + ...\)</p>
<p>Для точности выбрали число слагаемых n = 100.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Предупреждения</dt><dd>Формула для |x| &lt; 1. Остальные x приводим к этому интервалу.</dd></dl>
<p>Так как формула разложения в ряд Маклорена работает при |x| &lt; 1. То (1 + x) лежит в интервале от 0.0 до 2.0. Для расчета логарифма для произвольного числа необходимо вычитать единицу. Что и выполняется в функции.</p>
<p>Если посмотреть на график натурального логарифма, то при x близких к нулю график стремится в минус бесконечность. Поэтому график натурального логарифма и график ряда Маклорена плохо совпадают на интервале от 0 до 0.5. Достаточное совпадение происходит при x = 0.5. Поэтому выбираем интервал от 0.5 до 2.0. А интервал от 0 до 0.5 приводим к интервалу от 0.5 до 2.0</p>
<p>Также при x &gt; 2 график натурального логарифма и график ряда Маклорана плохо совпадают, поэтому этот интервал приводим к интервалу от 0.5 до 2.0.</p>
<p>Если x &gt;= 0.5 и x &lt;= 2.0 то сначала вычитаем единицу. Заводим цикл while пока не переберем все слагаемые. Внутри заводим переменную p, которая принимает значение -1.0 или 1.0 в зависимости от четности. Заводим цикл for, перебирая слагаемые, возводим x в нужную степень. Далее реализуем окончательную формулу для слагаемого ряда Маклорена с учетом знака.</p>
<p>Если |x| &gt; 2, то делаем преобразование над логарифмом \(\ ln(x) = -ln(1/x) \). Делается это для того, чтобы аргумент попадал в интервал от 0 до 0.5 или от 0.5 до 2. Причём если аргумент попадёт в интервал от 0 до 0.5, то в ходе преобразований он обязательно попадёт в интервал 0.5;2 и точно не перескочит этот интервал, снова попав в интервал от 2 до бескончности, из которого аргумент начал свой путь.</p>
<p>Если x &gt; 0.0 и x &lt; 0.5, то, используя свойста логарифмов \(\ ln(a*b) = ln(a) + ln(b) \), приводим к промежутку от 0.5 до 2.0. Если аргумент попадёт в интервал от 0 до 0.5, то в ходе преобразований он обязательно попадёт в интервал от 0.5 до 2 и точно не перескочит этот интервал, то есть не попадёт в интервал от 2 до бесконечности. </p>

</div>
</div>
<a id="ad2d8d5cd2b5e9edf4d08f34e03ac181e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d8d5cd2b5e9edf4d08f34e03ac181e">&#9670;&nbsp;</a></span>SMIlog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIlog </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Логарифм числа. </p>
<p>Функция возвращает логарифм числа.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>основание логирифма типа double </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>логирифма типа double</td></tr>
  </table>
  </dd>
</dl>
<p>Основана на свойстве \(\ log_a(b) = ln(b)/ln(a)\) </p>

</div>
</div>
<a id="a6f36797cbf72fdcd89feecb450fcd32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f36797cbf72fdcd89feecb450fcd32a">&#9670;&nbsp;</a></span>SMIpow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIpow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Функция \(\ x^n \). </p>
<dl class="section warning"><dt>Предупреждения</dt><dd>При целом n число x - любое (кроме случая x = 0 и n &lt;= 0). При действительном n число x &gt;= 0. </dd>
<dd>
Иррациональных чисел в C++ нет, поэтому вместо действительных рассматриваем рациональные.</dd></dl>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>степень числа типа double.</td></tr>
  </table>
  </dd>
</dl>
<ol type="1">
<li><p class="startli">Если n - целое, и его нельзя представить в виде дроби (т.к. тогда мы расширяем число до рациональных):</p>
<p class="startli">a)При x = 0 и n &lt;= 0, функция ничего не возвращает;</p>
<p class="startli">б)При x = 0 и n &gt; 0, функция возвращает ноль;</p>
<p class="startli">в)При отличном от нуля значении x и n = 0, функция возрващает ноль;</p>
<p class="startli">г)Если n &gt; 0, то с помощью цикла while возводим число x в нужную степень n;</p>
<p class="startli">д)При отцицательных значениях n и отличном от нуля значении x выводится</p>
</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> 1.0 / <a class="code" href="_math_functions_8cpp.html#abfe74579e99fa27d741e97f4edce2662">SMIpow</a>(x, -n);</div>
</div><!-- fragment --><p>То есть реализуем ранее созданную функцию, задав параметр -n (для того , чтобы работала как функция SMIpow с положительными значениями).</p>
<p>2.Если n - действительное (в нашем случае - просто рациональное):</p>
<dl class="section warning"><dt>Предупреждения</dt><dd>При x &lt; 0 ф-я не определена.</dd></dl>
<p>а)При нулевом значении x, функция возвращает ноль.</p>
<p>б)При x &gt; 0 выводится функция SMIexp с параметром (n*SMIln(x)). Для того, чтобы реализовать свойство \(\ e^{ln(x^n)} = x^n \) <br  />
 </p>

</div>
</div>
<a id="a4d2bf3695b1d2bc09487066ea01ccd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2bf3695b1d2bc09487066ea01ccd01">&#9670;&nbsp;</a></span>SMIround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SMIround </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Стандартное округление. </p>
<p>Функция возвращает округленное значение чмсла x.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double.</td></tr>
  </table>
  </dd>
</dl>
<p>Функция работает на основе SMIfloor(x) и SMIceil(x). И к входящему значению прибаляем 0.5 в SMIfloor(x), или же отнимаем 0.5 в SMIceil(x). Это делается для того, чтобы правильно работало округление положительных чисел и отрицательных чисел.</p>
<p>То есть для положительных чисел, если после запятой стоит число больше или равное 5, то путем прибавления 0.5 как раз в функции SMIfloor(x) округляется в большую сторону. Если после запятой стоит число меньшее пяти, то, даже с учетом дабавления 0.5, округляется в меньшую сторону.</p>
<p>Если числа отрицательные, то алгоритм тот же, только отнимаем 0.5 и используем функцию SMIceil(x). </p>

</div>
</div>
<a id="a17592d9867c7b061aee2b98cdf1be20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17592d9867c7b061aee2b98cdf1be20f">&#9670;&nbsp;</a></span>SMIsin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIsin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Синус. </p>
<p>Функция возвращает синус угла х (радианы). n - число, учавствующее в последнем члене ряда Маклорена. Онована на ряде Маклорена \(\ sin(x) = x - x^2 / 3! + x^5 / 5! - x^7 / 7! + ...\)</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double</td></tr>
  </table>
  </dd>
</dl>
<p>Функция работает с интервалом (-pi, pi). Остальные значения приводятся с помощью цикла while к этому интервалу.</p>
<p>Предварительно заводим переменную num, которая обозначает число учавствующее в последнем ряде Маклорена. Это делается для учета знака в формуле.</p>
<p>В результате выводится ответ реализованной формулы, с помощью уже описанных функций SMIpow и SMIfact. </p>

</div>
</div>
<a id="ad6c258aa57a2b36e8c08dbd110e8d24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c258aa57a2b36e8c08dbd110e8d24c">&#9670;&nbsp;</a></span>SMIsqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMIsqrt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Квадратный корень. </p>
<p>Функция возвращает квадратный корень числа x.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double</td></tr>
  </table>
  </dd>
</dl>
<p>Принцип работы: Сначала определяем в каких пределах может находится результат. Так как корень можно брать только из x &gt;= 0, то минимальный нижний предел равен нулю. Верхний предел либо х (если х&gt;1), либо 1 (если х&gt;0, х&lt;1).</p>
<p>Далее с помощью цикла while, пока находимся в выделенном отрезке, проверяем разность среднего арифметического концов отрезка с исходым значением x.</p>
<p>Если такая разность по модулю отличается только лишь на заданное эпсилон, то выводится результат.</p>
<p>Иначе проверяем следующие условия:</p>
<p>а)если разность меньше нуля, то нижним пределом теперь считаем найденное среднее арифметическое;</p>
<p>б)если не выполнились прошлые условия, то в таком случае разность получается положительной и верхним пределом считаем найденное среднее арифметическое. </p>

</div>
</div>
<a id="a296bd063698115c559b4acc0b0d55458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296bd063698115c559b4acc0b0d55458">&#9670;&nbsp;</a></span>SMItg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SMItg </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Тангенс. </p>
<p>Функция возвращает тангенс угла х (радианы).</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>входящий параметр типа double</td></tr>
  </table>
  </dd>
</dl>
<p>Реализуется по определению тангенса. Путем деления SMIsin(x) на SMIcos(x). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="a_math_functions_8cpp_html_abfe74579e99fa27d741e97f4edce2662"><div class="ttname"><a href="_math_functions_8cpp.html#abfe74579e99fa27d741e97f4edce2662">SMIpow</a></div><div class="ttdeci">double SMIpow(double x, double n)</div><div class="ttdoc">Функция .</div><div class="ttdef"><b>Definition:</b> MathFunctions.cpp:288</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_2c7e89309f7c31f95c313526dc54d8b1.html">SMI</a></li><li class="navelem"><a class="el" href="dir_cfa2602b460a193a5314e2290fe77214.html">SMI-1.0</a></li><li class="navelem"><a class="el" href="dir_10df9232951d453963541535f702cabb.html">MathFunctions</a></li><li class="navelem"><a class="el" href="_math_functions_8h.html">MathFunctions.h</a></li>
    <li class="footer">Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
