\hypertarget{_math_functions_8cpp}{}\doxysection{Файл D\+:/\+Road to the Dream/\+S\+M\+I/\+S\+M\+I-\/1.0/\+Math\+Functions/\+Math\+Functions.cpp}
\label{_math_functions_8cpp}\index{D:/Road to the Dream/SMI/SMI-\/1.0/MathFunctions/MathFunctions.cpp@{D:/Road to the Dream/SMI/SMI-\/1.0/MathFunctions/MathFunctions.cpp}}
\doxysubsection*{Функции}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{_math_functions_8cpp_abb8f3d7031ea88c4af7f4cd83e40e4b8}{S\+M\+Ifloor}} (double x)
\begin{DoxyCompactList}\small\item\em Функция округления вниз. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_math_functions_8cpp_a878d77c0ca2cd87a11ad4aef90975034}{S\+M\+Iceil}} (double x)
\begin{DoxyCompactList}\small\item\em Функция округления вверх. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_math_functions_8cpp_a4383c7642ac835f96758f2ff136e8599}{S\+M\+Iround}} (double x)
\begin{DoxyCompactList}\small\item\em Стандартное округление. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_a8f9a1606e8cf5e1c68ff1a7b6dc8df77}{S\+M\+Iabs}} (double x)
\begin{DoxyCompactList}\small\item\em Модуль числа. \end{DoxyCompactList}\item 
unsigned long long int \mbox{\hyperlink{_math_functions_8cpp_a7841c9b9b76e2868fa2206ce4d305328}{S\+M\+Ifact}} (unsigned int x)
\begin{DoxyCompactList}\small\item\em Факториал числа. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_a5d6ac311a731aff61dae523df5b0aa3d}{S\+M\+Iln}} (double x)
\begin{DoxyCompactList}\small\item\em Натуральный логарифм числа. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_a968fb90f62dc2db7dbf3f7341cbd331a}{S\+M\+Iexp}} (double x)
\begin{DoxyCompactList}\small\item\em Число е в степени x. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_abfe74579e99fa27d741e97f4edce2662}{S\+M\+Ipow}} (double x, double n)
\begin{DoxyCompactList}\small\item\em Функция $\ x^n $. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_a94325523a70bdae3d3c9be06dfbb425b}{S\+M\+Isqrt}} (double x)
\begin{DoxyCompactList}\small\item\em Квадратный корень. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_a285e7bb9c380a028a0d6dcbf7791c871}{S\+M\+Isin}} (double x)
\begin{DoxyCompactList}\small\item\em Синус. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_a38d6717af2a3fd53f13b9720fdc87aa8}{S\+M\+Icos}} (double x)
\begin{DoxyCompactList}\small\item\em Косинус. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_a425b1c164334764c84d9dcc79e33c894}{S\+M\+Itg}} (double x)
\begin{DoxyCompactList}\small\item\em Тангенс. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_aa9c334c3596112907ce4d1f6051b4e4e}{S\+M\+Ictg}} (double x)
\begin{DoxyCompactList}\small\item\em Котангенс. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_math_functions_8cpp_af5af202f1ae8c5621d85fe368b0d004d}{S\+M\+Ilog}} (double base, double argument)
\begin{DoxyCompactList}\small\item\em Логарифм числа. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Функции}
\mbox{\Hypertarget{_math_functions_8cpp_a8f9a1606e8cf5e1c68ff1a7b6dc8df77}\label{_math_functions_8cpp_a8f9a1606e8cf5e1c68ff1a7b6dc8df77}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIabs@{SMIabs}}
\index{SMIabs@{SMIabs}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIabs()}{SMIabs()}}
{\footnotesize\ttfamily double S\+M\+Iabs (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Модуль числа. 

Функция возвращает модуль числа x.

1.Если число типа double больше либо равно нулю, то функция возвращает это число.

2.Если число типа double меньше нуля, то функция возвращает противоположное число.


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_math_functions_8cpp_a878d77c0ca2cd87a11ad4aef90975034}\label{_math_functions_8cpp_a878d77c0ca2cd87a11ad4aef90975034}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIceil@{SMIceil}}
\index{SMIceil@{SMIceil}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIceil()}{SMIceil()}}
{\footnotesize\ttfamily int S\+M\+Iceil (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Функция округления вверх. 

Функция возвращает минимальное целое, которое не меньше x.

1.Если число типа double положительное и без остатка, то функция возвращает это число, округленное в тип int. В случае если число с остатком, то возвращается число преобразованное в тип int и увеличенное на единицу.

2.Если число типа double меньше либо равно нулю, то функция возвращает число преобразованное в тип int.


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_math_functions_8cpp_a38d6717af2a3fd53f13b9720fdc87aa8}\label{_math_functions_8cpp_a38d6717af2a3fd53f13b9720fdc87aa8}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIcos@{SMIcos}}
\index{SMIcos@{SMIcos}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIcos()}{SMIcos()}}
{\footnotesize\ttfamily double S\+M\+Icos (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Косинус. 

Функция возвращает косинус угла х (радианы).


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double\\
\hline
\end{DoxyParams}
Функция работает с использование функции S\+M\+Isin на основе формулы приведения $\ sin((pi/2) - x) = cos(x) $ \mbox{\Hypertarget{_math_functions_8cpp_aa9c334c3596112907ce4d1f6051b4e4e}\label{_math_functions_8cpp_aa9c334c3596112907ce4d1f6051b4e4e}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIctg@{SMIctg}}
\index{SMIctg@{SMIctg}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIctg()}{SMIctg()}}
{\footnotesize\ttfamily double S\+M\+Ictg (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Котангенс. 

Функция возвращает котангенс угла х (радианы).


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double\\
\hline
\end{DoxyParams}
Реализуется по определению котангенса. Путем деления S\+M\+Icos(x) на S\+M\+Isin(x). \mbox{\Hypertarget{_math_functions_8cpp_a968fb90f62dc2db7dbf3f7341cbd331a}\label{_math_functions_8cpp_a968fb90f62dc2db7dbf3f7341cbd331a}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIexp@{SMIexp}}
\index{SMIexp@{SMIexp}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIexp()}{SMIexp()}}
{\footnotesize\ttfamily double S\+M\+Iexp (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Число е в степени x. 

Функция возвращает $\ e^x $. Онована на ряде Маклорена $\ e^x = 1 + x / 1! + x^2 / 2! + x^3 / 3! + ...$(ограничились десятью слагаемыми)


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double\\
\hline
\end{DoxyParams}
Принцип работы\+:

1.Если $\vert$x$\vert$ $<$= 1.

Заводим цикл while пока не пройдем все слагаемые(n = 10) ряда Маклорена. Внутри заводим цикл for и возводим x в степень. Затем реализуем формулу ряда Маклорена с помощью факториала S\+M\+Ifact(n). И так пока не закончит работать цикл while.

2.Если x $\ > $ 1.

Здесь реализуется свойство степеней с одинаковыми основаниями $\ a^b * a^c = a^{b+c} $.

Для этого заводим две новые переменные, которые разделяют дробное число на целую часть и дробную.

Переменная x округляется вниз с помощью S\+M\+Ifloor(x), получая на выходе int\+\_\+x, а fract\+\_\+x находит дробную часть. Далее с помощью цикла for возводим e в целую степень, а в результате получаем произведение этой экспаненты на S\+M\+Iexp(fract\+\_\+x) (то есть e в оставшейся дробной степени).

3.Если x $<$ -\/1.\+0

Реализуется наподобие как и в пункте 2. Только округление отрицательных чисел производится с помощью S\+M\+Iceil(x). Далее представляем число в отрицательной степени как один делить на то же число только в положительной степени. И используем готовую функцию S\+M\+Iexp(fract\+\_\+x). \mbox{\Hypertarget{_math_functions_8cpp_a7841c9b9b76e2868fa2206ce4d305328}\label{_math_functions_8cpp_a7841c9b9b76e2868fa2206ce4d305328}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIfact@{SMIfact}}
\index{SMIfact@{SMIfact}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIfact()}{SMIfact()}}
{\footnotesize\ttfamily unsigned long long int S\+M\+Ifact (\begin{DoxyParamCaption}\item[{unsigned int}]{x }\end{DoxyParamCaption})}



Факториал числа. 

Функция возвращает факториал числа x.

\begin{DoxyWarning}{Предупреждения}
Функция не работает для x $>$ 20. Так как факториал очень быстро растет.
\end{DoxyWarning}
1.Функция работает по принципу рекурсии. Если число x типа unsigned int больше единицы, то значение x умножаем на вызов функции. И так до тех пор, пока x не станет равным единице или нулю.

2.Если число x типа unsigned int равняется единице или нулю, то функция возвращает единицу.


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа unsigned int . \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_math_functions_8cpp_abb8f3d7031ea88c4af7f4cd83e40e4b8}\label{_math_functions_8cpp_abb8f3d7031ea88c4af7f4cd83e40e4b8}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIfloor@{SMIfloor}}
\index{SMIfloor@{SMIfloor}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIfloor()}{SMIfloor()}}
{\footnotesize\ttfamily int S\+M\+Ifloor (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Функция округления вниз. 

Функция возвращает максимальное целое, не превышающее x.

1.Если число типа double больше или равно нуля, то функция возвращает это число преобразованное в тип int.

2.Если число типа double меньше нуля и без остатка, то функция возвращает это число преобразованное в тип int. В случае, если число отрицательное и дробое, то функция возвращает число преобразованное в int, уменьшенное на единицу.(Например, число -\/3,5 округлится до -\/4)


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_math_functions_8cpp_a5d6ac311a731aff61dae523df5b0aa3d}\label{_math_functions_8cpp_a5d6ac311a731aff61dae523df5b0aa3d}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIln@{SMIln}}
\index{SMIln@{SMIln}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIln()}{SMIln()}}
{\footnotesize\ttfamily double S\+M\+Iln (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Натуральный логарифм числа. 

Функция ln(x). $\ ln(1+x) = x - x^2 / 2 + x^3 / 3 - x^4 / 4 + ...$

Для точности выбрали число слагаемых n = 100.


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Предупреждения}
Формула для $\vert$x$\vert$ $<$ 1. Остальные x приводим к этому интервалу.
\end{DoxyWarning}
Так как формула разложения в ряд Маклорена работает при $\vert$x$\vert$ $<$ 1. То (1 + x) лежит в интервале от 0.\+0 до 2.\+0. Для расчета логарифма для произвольного числа необходимо вычитать единицу. Что и выполняется в функции.

Если посмотреть на график натурального логарифма, то при x близких к нулю график стремится в минус бесконечность. Поэтому график натурального логарифма и график ряда Маклорена плохо совпадают на интервале от 0 до 0.\+5. Достаточное совпадение происходит при x = 0.\+5. Поэтому выбираем интервал от 0.\+5 до 2.\+0. А интервал от 0 до 0.\+5 приводим к интервалу от 0.\+5 до 2.\+0

Также при x $>$ 2 график натурального логарифма и график ряда Маклорана плохо совпадают, поэтому этот интервал приводим к интервалу от 0.\+5 до 2.\+0.

Если x $>$= 0.\+5 и x $<$= 2.\+0 то сначала вычитаем единицу. Заводим цикл while пока не переберем все слагаемые. Внутри заводим переменную p, которая принимает значение -\/1.\+0 или 1.\+0 в зависимости от четности. Заводим цикл for, перебирая слагаемые, возводим x в нужную степень. Далее реализуем окончательную формулу для слагаемого ряда Маклорена с учетом знака.

Если $\vert$x$\vert$ $>$ 2, то делаем преобразование над логарифмом $\ ln(x) = -ln(1/x) $. Делается это для того, чтобы аргумент попадал в интервал от 0 до 0.\+5 или от 0.\+5 до 2. Причём если аргумент попадёт в интервал от 0 до 0.\+5, то в ходе преобразований он обязательно попадёт в интервал 0.\+5;2 и точно не перескочит этот интервал, снова попав в интервал от 2 до бескончности, из которого аргумент начал свой путь.

Если x $>$ 0.\+0 и x $<$ 0.\+5, то, используя свойста логарифмов $\ ln(a*b) = ln(a) + ln(b) $, приводим к промежутку от 0.\+5 до 2.\+0. Если аргумент попадёт в интервал от 0 до 0.\+5, то в ходе преобразований он обязательно попадёт в интервал от 0.\+5 до 2 и точно не перескочит этот интервал, то есть не попадёт в интервал от 2 до бесконечности. \mbox{\Hypertarget{_math_functions_8cpp_af5af202f1ae8c5621d85fe368b0d004d}\label{_math_functions_8cpp_af5af202f1ae8c5621d85fe368b0d004d}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIlog@{SMIlog}}
\index{SMIlog@{SMIlog}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIlog()}{SMIlog()}}
{\footnotesize\ttfamily double S\+M\+Ilog (\begin{DoxyParamCaption}\item[{double}]{base,  }\item[{double}]{argument }\end{DoxyParamCaption})}



Логарифм числа. 

Функция возвращает логарифм числа.


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em base} & основание логирифма типа double \\
\hline
\mbox{\texttt{ in}}  & {\em argument} & логирифма типа double\\
\hline
\end{DoxyParams}
Основана на свойстве $\ log_a(b) = ln(b)/ln(a)$ \mbox{\Hypertarget{_math_functions_8cpp_abfe74579e99fa27d741e97f4edce2662}\label{_math_functions_8cpp_abfe74579e99fa27d741e97f4edce2662}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIpow@{SMIpow}}
\index{SMIpow@{SMIpow}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIpow()}{SMIpow()}}
{\footnotesize\ttfamily double S\+M\+Ipow (\begin{DoxyParamCaption}\item[{double}]{x,  }\item[{double}]{n }\end{DoxyParamCaption})}



Функция $\ x^n $. 

\begin{DoxyWarning}{Предупреждения}
При целом n число x -\/ любое (кроме случая x = 0 и n $<$= 0). При действительном n число x $>$= 0. 

Иррациональных чисел в C++ нет, поэтому вместо действительных рассматриваем рациональные.
\end{DoxyWarning}

\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double. \\
\hline
\mbox{\texttt{ in}}  & {\em n} & степень числа типа double.\\
\hline
\end{DoxyParams}

\begin{DoxyEnumerate}
\item Если n -\/ целое, и его нельзя представить в виде дроби (т.\+к. тогда мы расширяем число до рациональных)\+:

a)При x = 0 и n $<$= 0, функция ничего не возвращает;

б)При x = 0 и n $>$ 0, функция возвращает ноль;

в)При отличном от нуля значении x и n = 0, функция возрващает ноль;

г)Если n $>$ 0, то с помощью цикла while возводим число x в нужную степень n;

д)При отцицательных значениях n и отличном от нуля значении x выводится
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{return} 1.0 / \mbox{\hyperlink{_math_functions_8cpp_abfe74579e99fa27d741e97f4edce2662}{SMIpow}}(x, -\/n);}
\end{DoxyCode}


То есть реализуем ранее созданную функцию, задав параметр -\/n (для того , чтобы работала как функция S\+M\+Ipow с положительными значениями).

2.Если n -\/ действительное (в нашем случае -\/ просто рациональное)\+:

\begin{DoxyWarning}{Предупреждения}
При x $<$ 0 ф-\/я не определена.
\end{DoxyWarning}
а)При нулевом значении x, функция возвращает ноль.

б)При x $>$ 0 выводится функция S\+M\+Iexp с параметром (n$\ast$\+S\+M\+Iln(x)). Для того, чтобы реализовать свойство $\ e^{ln(x^n)} = x^n $ ~\newline
 \mbox{\Hypertarget{_math_functions_8cpp_a4383c7642ac835f96758f2ff136e8599}\label{_math_functions_8cpp_a4383c7642ac835f96758f2ff136e8599}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIround@{SMIround}}
\index{SMIround@{SMIround}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIround()}{SMIround()}}
{\footnotesize\ttfamily int S\+M\+Iround (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Стандартное округление. 

Функция возвращает округленное значение чмсла x.


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double.\\
\hline
\end{DoxyParams}
Функция работает на основе S\+M\+Ifloor(x) и S\+M\+Iceil(x). И к входящему значению прибаляем 0.\+5 в S\+M\+Ifloor(x), или же отнимаем 0.\+5 в S\+M\+Iceil(x). Это делается для того, чтобы правильно работало округление положительных чисел и отрицательных чисел.

То есть для положительных чисел, если после запятой стоит число больше или равное 5, то путем прибавления 0.\+5 как раз в функции S\+M\+Ifloor(x) округляется в большую сторону. Если после запятой стоит число меньшее пяти, то, даже с учетом дабавления 0.\+5, округляется в меньшую сторону.

Если числа отрицательные, то алгоритм тот же, только отнимаем 0.\+5 и используем функцию S\+M\+Iceil(x). \mbox{\Hypertarget{_math_functions_8cpp_a285e7bb9c380a028a0d6dcbf7791c871}\label{_math_functions_8cpp_a285e7bb9c380a028a0d6dcbf7791c871}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIsin@{SMIsin}}
\index{SMIsin@{SMIsin}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIsin()}{SMIsin()}}
{\footnotesize\ttfamily double S\+M\+Isin (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Синус. 

Функция возвращает синус угла х (радианы). n -\/ число, учавствующее в последнем члене ряда Маклорена. Онована на ряде Маклорена $\ sin(x) = x - x^2 / 3! + x^5 / 5! - x^7 / 7! + ...$


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double\\
\hline
\end{DoxyParams}
Функция работает с интервалом (-\/pi, pi). Остальные значения приводятся с помощью цикла while к этому интервалу.

Предварительно заводим переменную num, которая обозначает число учавствующее в последнем ряде Маклорена. Это делается для учета знака в формуле.

В результате выводится ответ реализованной формулы, с помощью уже описанных функций S\+M\+Ipow и S\+M\+Ifact. \mbox{\Hypertarget{_math_functions_8cpp_a94325523a70bdae3d3c9be06dfbb425b}\label{_math_functions_8cpp_a94325523a70bdae3d3c9be06dfbb425b}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMIsqrt@{SMIsqrt}}
\index{SMIsqrt@{SMIsqrt}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMIsqrt()}{SMIsqrt()}}
{\footnotesize\ttfamily double S\+M\+Isqrt (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Квадратный корень. 

Функция возвращает квадратный корень числа x.


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double\\
\hline
\end{DoxyParams}
Принцип работы\+: Сначала определяем в каких пределах может находится результат. Так как корень можно брать только из x $>$= 0, то минимальный нижний предел равен нулю. Верхний предел либо х (если х$>$1), либо 1 (если х$>$0, х$<$1).

Далее с помощью цикла while, пока находимся в выделенном отрезке, проверяем разность среднего арифметического концов отрезка с исходым значением x.

Если такая разность по модулю отличается только лишь на заданное эпсилон, то выводится результат.

Иначе проверяем следующие условия\+:

а)если разность меньше нуля, то нижним пределом теперь считаем найденное среднее арифметическое;

б)если не выполнились прошлые условия, то в таком случае разность получается положительной и верхним пределом считаем найденное среднее арифметическое. \mbox{\Hypertarget{_math_functions_8cpp_a425b1c164334764c84d9dcc79e33c894}\label{_math_functions_8cpp_a425b1c164334764c84d9dcc79e33c894}} 
\index{MathFunctions.cpp@{MathFunctions.cpp}!SMItg@{SMItg}}
\index{SMItg@{SMItg}!MathFunctions.cpp@{MathFunctions.cpp}}
\doxysubsubsection{\texorpdfstring{SMItg()}{SMItg()}}
{\footnotesize\ttfamily double S\+M\+Itg (\begin{DoxyParamCaption}\item[{double}]{x }\end{DoxyParamCaption})}



Тангенс. 

Функция возвращает тангенс угла х (радианы).


\begin{DoxyParams}[1]{Аргументы}
\mbox{\texttt{ in}}  & {\em x} & входящий параметр типа double\\
\hline
\end{DoxyParams}
Реализуется по определению тангенса. Путем деления S\+M\+Isin(x) на S\+M\+Icos(x). 