/*!
    \brief Функция округления вниз.

    Функция возвращает максимальное целое, не превышающее x.

    1.Если число типа double больше или равно нуля, то функция возвращает это число преобразованное в тип int.

    2.Если число типа double меньше нуля и без остатка, то функция возвращает это число преобразованное в тип int.
    В случае, если число отрицательное и дробое, то функция возвращает число преобразованное в int, уменьшенное на единицу.(Например, число -3,5 округлится до -4)

    \param[in] x входящий параметр типа double.

*/
int SMIfloor(double x)
{
    if (x >= 0)
        return (int)x;
    if (x < 0)
    {
        if (x == (double)((int)x))
            return (int)x;
        else
            return (int)x - 1;
    }
}

/*!
    \brief Функция округления вверх.

    Функция возвращает минимальное целое, которое не меньше x.

    1.Если число типа double положительное и без остатка, то функция возвращает это число, округленное в тип int. В случае если число с остатком,
    то возвращается число преобразованное в тип int и увеличенное на единицу.

    2.Если число типа double меньше либо равно нулю,  то функция возвращает число преобразованное в тип int.

    
    \param[in] x входящий параметр типа double.
*/
int SMIceil(double x)
{
    if (x > 0)
    {
        if (x == (double)((int)x))
            return (int)x;
        else
            return (int)x + 1;
    }
    if (x <= 0)
        return (int)x;
}

// Возвращает округлённое значение числа x.
/*!
    \brief Стандартное округление.

    Функция возвращает округленное значение чмсла x.

    \param[in] x входящий параметр типа double.

    Функция работает на основе SMIfloor(x) и SMIceil(x). И к входящему значению прибаляем 0.5 в SMIfloor(x),
    или же отнимаем 0.5 в SMIceil(x). Это делается для того, чтобы правильно работало округление положительных чисел и отрицательных чисел.

    То есть для положительных чисел, если после запятой стоит число больше или равное 5, то путем прибавления 0.5 как раз в функции SMIfloor(x)
    округляется в большую сторону. Если после запятой стоит число меньшее пяти, то, даже с учетом дабавления 0.5, округляется в меньшую сторону.

    Если числа отрицательные, то алгоритм тот же, только отнимаем 0.5 и используем функцию SMIceil(x).
*/
int SMIround(double x)
{
    if (x >= 0)
        return SMIfloor(x + 0.5);
    if (x < 0)
        return SMIceil(x - 0.5);
}

/*!
    \brief Модуль числа.

    Функция возвращает модуль числа x.

    1.Если число типа double больше либо равно нулю, то функция возвращает это число.


    2.Если число типа double меньше нуля, то функция возвращает противоположное число.


    \param[in] x входящий параметр типа double.
*/
double SMIabs(double x)
{
    if (x >= 0)
        return x;
    else
        return -x;
}

/*!
    \brief Факториал числа.

    Функция возвращает факториал числа x.

    \warning Функция не работает для x > 20. Так как факториал очень быстро растет.

    1.Функция работает по принципу рекурсии. Если число x типа unsigned int больше единицы, то значение x умножаем на вызов функции. 
    И так до тех пор, пока x не станет равным единице или нулю. 
    
    2.Если число x типа unsigned int равняется единице или нулю, то функция возвращает единицу.


    \param[in] x входящий параметр типа unsigned int .
*/
unsigned long long int SMIfact(unsigned int x)
{
    if (x > 1)
        return x * SMIfact(x - 1);
    if (x == 1)
        return 1;
    if (x == 0)
        return 1;
}


/*!
    \brief Натуральный логарифм числа.

    Функция ln(x). \f$\ ln(1+x) = x - x^2 / 2 + x^3 / 3 - x^4 / 4 + ...\f$

    Для точности выбрали число слагаемых n = 100.

    \param[in] x входящий параметр типа double

    \warning Формула для |x| < 1. Остальные x приводим к этому интервалу.

    Так как формула разложения в ряд Маклорена работает при |x| < 1. То (1 + x) лежит в интервале от 0.0 до 2.0. 
    Для расчета логарифма для произвольного числа необходимо вычитать единицу. Что и выполняется в функции.

    Если посмотреть на график натурального логарифма, то при x близких к нулю график стремится в минус бесконечность.
    Поэтому график натурального логарифма и график ряда Маклорена плохо совпадают на интервале от 0 до 0.5.
    Достаточное совпадение происходит при x = 0.5. Поэтому выбираем интервал от 0.5 до 2.0.
    А интервал от 0 до 0.5 приводим к интервалу от 0.5 до 2.0

    Также при x > 2 график натурального логарифма и график ряда Маклорана плохо совпадают, 
    поэтому этот интервал приводим к интервалу от 0.5 до 2.0.

    
    Если x >= 0.5 и x <= 2.0 то сначала вычитаем единицу. Заводим цикл while пока не переберем все слагаемые.
    Внутри заводим переменную  p, которая принимает значение -1.0 или 1.0 в зависимости от четности.
    Заводим цикл for, перебирая слагаемые, возводим x в нужную степень. Далее реализуем окончательную формулу 
    для слагаемого ряда Маклорена с учетом знака. 

    Если |x| > 2, то делаем преобразование над логарифмом \f$\ ln(x) = -ln(1/x) \f$.
    Делается это для того, чтобы аргумент попадал в интервал от 0 до 0.5 или от 0.5 до 2. Причём если аргумент попадёт
    в интервал от 0 до 0.5, то в ходе преобразований он обязательно попадёт в интервал 0.5;2 и точно не перескочит
    этот интервал, снова попав в интервал от 2 до бескончности, из которого аргумент начал свой путь.

    Если x > 0.0 и x < 0.5, то, используя свойста логарифмов \f$\ ln(a*b) = ln(a) + ln(b) \f$, 
    приводим к промежутку от 0.5 до 2.0. Если аргумент попадёт в интервал от 0 до 0.5, то в ходе преобразований он
    обязательно попадёт в интервал от 0.5 до 2 и точно не перескочит этот интервал, то есть не попадёт в интервал от 2 до бесконечности.
    
    
*/
double SMIln(double x)
{
    unsigned int n = 100; // Вынес из параметра по умолчанию для облегчения работы с Bison.
    if (x >= 0.5 && x <= 2.0)
    {
        double res = 0.0;
        x--;
        while (n)
        {
            const double p = (n % 2 == 0) ? -1.0 : 1.0; // Если n - чётное, то p = -1.0, иначе p = 1.0.
            double powValue = 1.0; 
            for(int i = n; i != 0; i--){ powValue *= x; }
            res += powValue / (p * n);
            n--;
        }
        return res;
    }
    if (x > 2.0)
        return -SMIln(1.0 / x);
    if (x > 0.0 && x < 0.5)
        return SMIln(2 * x) + SMIln(0.5);
}

/*!
    \brief Число е в степени x.

    Функция возвращает \f$\ e^x \f$. Онована на ряде Маклорена \f$\ e^x = 1 + x / 1! + x^2 / 2! + x^3 / 3! + ...\f$(ограничились десятью слагаемыми)

    \param[in] x входящий параметр типа double

    Принцип работы:

    1.Если |x| <= 1.

    Заводим цикл while пока не пройдем все слагаемые(n = 10) ряда Маклорена. 
    Внутри заводим цикл for и возводим x в степень. Затем реализуем формулу ряда Маклорена с помощью факториала SMIfact(n).
    И так пока не закончит работать цикл while.

    2.Если x \f$\ > \f$ 1.

    Здесь реализуется свойство степеней с одинаковыми основаниями \f$\ a^b * a^c = a^{b+c} \f$.

    Для этого заводим две новые переменные, которые разделяют дробное число на целую часть и дробную. 

    Переменная x округляется вниз с помощью SMIfloor(x), получая на выходе int_x, а fract_x находит дробную часть.
    Далее с помощью цикла for возводим e в целую степень, а в результате получаем произведение этой
    экспаненты на SMIexp(fract_x) (то есть e в оставшейся дробной степени).

    3.Если x < -1.0

    Реализуется наподобие как и в пункте 2. Только округление отрицательных чисел
    производится с помощью SMIceil(x). Далее представляем число в отрицательной степени 
    как один делить на то же число только в положительной степени. И используем готовую
    функцию SMIexp(fract_x).

*/
double SMIexp(double x)
{
    unsigned int n = 10;
    if (SMIabs(x) <= 1.0)
    {
        double res = 1.0;
        while (n)
        {
            double powValue = 1.0; 
            for(int i = n; i != 0; i--){ powValue *= x; }
            res += powValue / (double)SMIfact(n);
            n--;
        }
        return res;
    }
    double e = 2.71828182845904523536;
    if (x > 1.0)
    {
        double int_x = SMIfloor(x), fract_x = x - int_x;
        double powValue = 1.0;
        for(int i = int_x; i != 0; i--){ powValue *= e; }
        return powValue * SMIexp(fract_x);
    }
    if (x < -1.0)
    {
        double int_x = SMIceil(x), fract_x = x - int_x;
        double powValue = 1.0;
        for(int i = int_x; i != 0; i++){ powValue *= e; }
        powValue = 1.0 / powValue;
        return powValue * SMIexp(fract_x);
    }
}

/*!
    \brief Функция \f$\ x^n \f$.

    \warning При целом n число x - любое (кроме случая x = 0 и n <= 0). При действительном n число x >= 0.
    \warning Иррациональных чисел в C++ нет, поэтому вместо действительных рассматриваем рациональные.

    \param[in] x входящий параметр типа double.
    \param[in] n степень числа типа double.


    1. Если n - целое, и его нельзя представить в виде дроби (т.к. тогда мы расширяем число до рациональных):
        
        a)При x = 0 и  n <= 0, функция ничего не возвращает;
        
        б)При x = 0 и n > 0, функция возвращает ноль;
        
        в)При отличном от нуля значении x и n = 0, функция возрващает ноль;
        
        г)Если n > 0, то с помощью цикла while возводим число x в нужную степень n;

        д)При отцицательных значениях n и отличном от нуля значении x выводится 

        \code
            return 1.0 / SMIpow(x, -n);
        \endcode

        То есть реализуем ранее созданную функцию, задав параметр -n (для того , чтобы работала как функция SMIpow с положительными значениями).

     2.Если n - действительное (в нашем случае - просто рациональное):
        
        \warning При x < 0 ф-я не определена.

        а)При нулевом значении x, функция возвращает ноль.

        б)При x > 0 выводится функция SMIexp с параметром (n*SMIln(x)). Для того, чтобы реализовать свойство \f$\ e^{ln(x^n)} = x^n \f$    
*/
double SMIpow(double x, double n)
{
    if (n == (double)((int)n)) // Если n - целое, и его нельзя представить в виде дроби (т.к. тогда мы расширяем число до рациональных).
    {
        if (x == 0.0 && n <= 0.0)
        {
            // Ничего не возвращает.
        }
        if (x == 0.0 && n > 0.0)
            return 0.0;
        if (x != 0.0 && n == 0.0)
            return 1.0;
        if (n > 0.0)
        {
            double res = 1.0;
            while (n--)
            {
                res *= x;
            }
            return res;
        }
        if (x != 0.0 && n < 0.0)
            return 1.0 / SMIpow(x, -n);
    }
    else // Если n - действительное (в нашем случае - просто рациональное). При x < 0 ф-я не определена.
    {
        if (x == 0.0)
            return 0.0;
        if (x > 0.0)
            return SMIexp(n * SMIln(x));
    }
}

/*!
    \brief Квадратный корень.

    Функция возвращает квадратный корень числа x.

    \param[in] x входящий параметр типа double

    Принцип работы:
    Сначала определяем в каких пределах может находится результат. Так как корень можно брать только из x >= 0,
    то минимальный нижний предел равен нулю. Верхний предел либо х (если х>1), либо 1 (если х>0, х<1).

    Далее с помощью цикла while, пока находимся в выделенном отрезке, проверяем разность среднего арифметического концов отрезка с исходым значением x.

    Если такая разность по модулю отличается только лишь на заданное эпсилон, то выводится результат.

    Иначе проверяем следующие условия:

    а)если разность меньше нуля, то нижним пределом теперь считаем найденное среднее арифметическое;

    б)если не выполнились прошлые условия, то в таком случае разность получается положительной 
    и верхним пределом считаем найденное среднее арифметическое.


*/
double SMIsqrt(double x)
{
    double epsilon = 0.0001;
    if (x >= 0)
    {
        double low = 0.0;
        double high = (x > 1) ? x : 1.0;
        double result;
        double difference;
        while (low <= high)
        {
            result = (low + high) / 2;
            difference = SMIpow(result, 2) - x;
            if (SMIabs(difference) < epsilon)
                return result;
            else
            {
                if (difference < 0)
                    low = result;
                else
                    high = result;
            }
        }
    }
}

/*!
    \brief Синус.

    Функция возвращает синус угла х (радианы). n - число, учавствующее в последнем члене ряда Маклорена. 
    Онована на ряде Маклорена \f$\ sin(x) = x - x^2 / 3! + x^5 / 5! - x^7 / 7! + ...\f$

    \param[in] x входящий параметр типа double

    Функция работает с интервалом (-pi, pi). Остальные значения приводятся с помощью цикла while к этому интервалу.

    Предварительно заводим переменную num, которая обозначает число учавствующее в последнем ряде Маклорена. Это делается для учета знака в формуле.

    В результате выводится ответ реализованной формулы, с помощью уже описанных функций SMIpow и SMIfact.

*/
double SMIsin(double x)
{
    unsigned int n = 10;
    const double pi = 3.14159265358979323846;
    double res = 0.0;
    int num = n * 2 - 1; // Число, участвующее в последнем члене ряда Маклорена.
    // Первые два цикла while приводят х к интервалу (-pi, pi).
    while (x > pi)
    {
        x -= 2.0 * pi;
    }
    while (x < -pi)
    {
        x += 2.0 * pi;
    }
    if (x == pi) // Без этого условия будет возвращать число, очень близкое к нулю. Но нужен именно 0.
        return 0.0;
    while (num + 1)
    {
        const double p = (((num + 1) / 2) % 2 == 0) ? -1.0 : 1.0; // (num + 1) / 2 - номер текущего члена.
        res += SMIpow(x, num) / (double)(SMIfact(num) * p);
        num -= 2;
    }
    return res;
}

/*!
    \brief Косинус.

    Функция возвращает косинус угла х (радианы).

    \param[in] x входящий параметр типа double

    Функция работает с использование функции SMIsin на основе формулы приведения \f$\ sin((pi/2) - x) = cos(x) \f$
*/
double SMIcos(double x)
{
    const double pi = 3.14159265358979323846;
    return SMIsin(pi / 2.0 - x);
}

/*!
    \brief Тангенс.

    Функция возвращает тангенс угла х (радианы).

    \param[in] x входящий параметр типа double

    Реализуется по определению тангенса. Путем деления SMIsin(x) на SMIcos(x).
*/
double SMItg(double x)
{
    return (double)SMIsin(x) / SMIcos(x);
}

/*!
    \brief Котангенс.

    Функция возвращает котангенс угла х (радианы).

    \param[in] x входящий параметр типа double

    Реализуется по определению котангенса. Путем деления SMIcos(x) на SMIsin(x).
*/
double SMIctg(double x)
{
    return (double)SMIcos(x) / SMIsin(x);
}

// Возвращает логарифм по основанию base от аргумента argument.
/*!
    \brief Логарифм числа.

    Функция возвращает логарифм числа. 

    \param[in] base основание логирифма типа double
    \param[in] argument логирифма типа double
    
    Основана на свойстве \f$\ log_a(b) = ln(b)/ln(a)\f$

*/
double SMIlog(double base, double argument)
{
    unsigned int n = 100;
    if (base > 0.0 && base != 1.0 && argument > 0.0)
        return (double)SMIln(argument) / SMIln(base);
}
